---
slug: "collection-of-graph-algorithms-in-python3"
title: "Collection of Graph Algorithms in Python3"
author: "Jasper Hwong"
avatar: "https://avatars.githubusercontent.com/u/48860446?s=400&u=8fff5d79830aa932769873b301fb2cabdaa3ffaa&v=4"
date: "23 Aug 2023"
---

Graph problems are intereseting and fun. It's my favourite coding problem variant of all times!
This post is heavily inspried by a Leetcode [study guide](https://leetcode.com/discuss/study-guide/1326900/graph-algorithms-problems-to-practice).

# Terminology

First, let's talk about some terminologies that we will use for the rest of the content.

1. Graph: A graph in dscrete mathematics is a structure amounting to a set of objects in which some paris of objects are is some sense "related".
2. Vertex/vertices: A vertex is a single object abstraction (or we normally call it a node) in a graph.
3. Edge/edges: An edge is a line connecting two node/vertices in a graph. An edge can be directed or undirected. An directed edge from A to B, is strictly irrevisible from B to A. Whilst, undirected edge between A and B can be travelled from both ends.
4. Weighted graph: An weighted graph is a type of graph whereby a number is assigned to each edge. Such weight can be represented as certain value like cost, time, capacities, etc.
5. Bipartite graph: A bipartite graph is a grah where all nodes can be divided into two sets, say W and X. So that, no two nodes in W share a common edge, as well as X.
6. Tree: A tree is an undirected graph in which any two vertices are connected by exactly on path, or sometimes a connected acyclic undirected graph.

## Generate a Graph

Depends on the input that the question has provided, normally the inputs will be an array of `edges`, to represent the connectivity of all nodes.
Below, is an example of generating an `adjacency list` to represent a undirected graph.

```python
    graph = collections.defaultdict(list)
    for u, v in paths:
        graph[u].append(v)
        graph[v].append(u)
```

# Traversal Algorithms

We have two famous traversal algorithm to solve a graph problem. A traversal algorithm can be defined as an algorithm to search a node or traverse from node to node.

## Depth First Search

A DFS can be implemented by using a recursive function. So, based on the graph that we have generated above,

```python
    visited = set()

    def dfs(node):
        if node not in visited:
            visited.add(node)
            # Do something here
            for v in graph[u]:
                dfs(node)
        return
```

We use a `set` here to make sure we won't visit a visited node again in `O(1)` time.

## Breath First Search

A BFS tends to look for the neighbouring nodes first, and then visit the subsequent degree nodes. Hence, we often say it is visiting nodes layer by layer.
Since, its nature of visiting nodes from the first degree, it is often used to search for a shortest target/node. We use a queue or priority queue to implement a BFS.

```python
    visited = set()
    bfs = collections.deque([startNode])

    while bfs:
        u = bfs.popleft()
        if u == target:
            # Do something
            return True
        visited.add(node)
        for v in graph[u]:
            if v not in visited:
                bfs.append(v)

    return False
```

## Dijkstra's Algorithm

Dijkstra's Algorithm is used to find a shortest paths between a given node (starting node) to other nodes in a graph.
This algorithm uses the weights of the edges to find the path that minimize the total distance between the source and other nodes.
It utilizes a `priority queue` and will always process the smallest edge's cost in the heap. Thus, we are able to produce the optimal cost to reach the target node.
Below shows an example from network delay problem in a directed graph.

```python
        graph = collections.defaultdict(list)
        for u, v, w in times: # source, dest, cost
            graph[u].append((w, v))

        heap = [(0, k)]
        dist = [float(inf)] * (n)
        visited = set()
        dist[k] = 0

        while pq:
            w, u = heapq.heappop(pq)
            if u in visited: continue
            visited.add(u)
            if dist[u] < w: continue
            for v, cost in graph[u]:
                if dist[v] > dist[u] + cost:
                    dist[v] = dist[u] + cost
                    heapq.heappush(pq, (dist[v], v))
        res = max(dist[1:])
        return res if res != float('inf') else -1
```
